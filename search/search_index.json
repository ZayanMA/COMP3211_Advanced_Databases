{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"COMP3211 \u2014 Advanced Databases Notes","text":"<p>These notes are AI-drafted, then human-refined. They aim to be concise, accurate, and aligned to the lecture content.</p>"},{"location":"#how-to-use-this-site","title":"How to use this site","text":"<ul> <li>Use the left sidebar to navigate between lectures.</li> <li>Use the Contents panel on the right to jump within a lecture page.</li> <li>Code blocks are used for SQL / pseudocode; maths is used for definitions and formal notation.</li> </ul>"},{"location":"#source-status","title":"Source + status","text":"<ul> <li>Module: COMP3211 Advanced Databases</li> <li>Status: Work in progress \u2014 pages will be added/updated as the course progresses.</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Repository: GitHub</li> </ul>"},{"location":"#notes","title":"Notes","text":"<ul> <li>Data Types and Operations</li> <li>DBMS Architecture</li> <li>Storage</li> </ul>"},{"location":"data_types_and_operations/","title":"Data Types and Operations","text":""},{"location":"data_types_and_operations/#overview","title":"Overview","text":"<p>Advanced DBMSs must support non-traditional data types (temporal, spatial, multimedia) and provide suitable operations for querying them. A key theme: not every operation makes sense for every type, so systems must define meaningful operations (and avoid misleading ones).</p>"},{"location":"data_types_and_operations/#data-types","title":"Data Types","text":"<p>Common types covered:</p> <ul> <li> <p>Numeric (integers, reals)</p> </li> <li> <p>Character (strings)</p> </li> <li> <p>Temporal (time-oriented data)</p> </li> <li> <p>Spatial (geometric data in 2D/3D)</p> </li> <li> <p>Text (documents, semi/unstructured text)</p> </li> <li> <p>Image (still images)</p> </li> <li> <p>Audio &amp; Video (multimedia streams/files)</p> </li> </ul>"},{"location":"data_types_and_operations/#operations-on-data","title":"Operations on Data","text":"<p>Typical operation families:</p> <ul> <li> <p>Comparison: equality, ordering, similarity</p> </li> <li> <p>Arithmetic: addition, multiplication, concatenating strings etc.</p> </li> <li> <p>Fuzzy search / similarity: regex / approximate matching (especially for     text/media)</p> </li> <li> <p>Information retrieval queries: e.g.\u00a0documents containing a word;     images containing a feature</p> </li> </ul> <p>Definition</p> <p>Meaningful operation: An operation is meaningful when its result has a clear, consistent interpretation for that data type. If an operation is undefined or ambiguous, it should not be treated as a normal operator.</p> <p>Operations: what's meaningful?</p> <p>Units matter (weights vs numbers):</p> <ul> <li> <p>\\(2\\,\\text{kg} + 2\\,\\text{kg}\\) \\(\\rightarrow\\) meaningful (same unit,     additive quantity)</p> </li> <li> <p>\\(2\\,\\text{kg} \\times 2\\,\\text{kg}\\) \\(\\rightarrow\\) generally not     meaningful in normal DB semantics (unit becomes kg\\(^2\\))</p> </li> <li> <p>\\(13 + 2\\,\\text{kg}\\) \\(\\rightarrow\\) meaningless (incompatible kinds)</p> </li> <li> <p>\\(13 \\times 2\\,\\text{kg}\\) \\(\\rightarrow\\) meaningful (scale a     quantity by a factor)</p> </li> </ul> <p>Media types:</p> <ul> <li> <p>\"Compare two images for equality\" can be meaningful, to see if they are the same object.</p> </li> <li> <p>\"Add two images\" is ambiguous unless the system defines a specific     image-processing meaning.</p> </li> </ul>"},{"location":"data_types_and_operations/#ordering-total-vs-partial-orders","title":"Ordering: Total vs Partial Orders","text":"<p>A common question for any type is: is it ordered, and what kind of order?</p> <p>Definition</p> <p>Total order: any two values are comparable (for any \\(a,b\\), either \\(a\\le b\\) or \\(b\\le a\\)). Partial order: some pairs may be incomparable (neither \\(a\\le b\\) nor \\(b\\le a\\) holds).</p> <p>Note</p> <p>Even if you can impose an order (e.g.\u00a0by ID), the key question is whether the order has semantic meaning or is just a convenience.</p>"},{"location":"data_types_and_operations/#temporal-data","title":"Temporal Data","text":"<p>Temporal data adds the time dimension to support questions such as:</p> <ul> <li> <p>Average price of product \\(X\\) during 1995</p> </li> <li> <p>Month with the most copies sold of video \\(Y\\)</p> </li> <li> <p>Treatment history of patient \\(Z\\)</p> </li> </ul>"},{"location":"data_types_and_operations/#characteristics-of-time","title":"Characteristics of Time","text":"<p>Time can differ by:</p> <ul> <li> <p>Structure: linear; branching time (possible futures); directed     acyclic graph (merge together at some point in time but then split out again); periodic/cyclic (Different cycles: 24 hours, monthly, yearly)</p> </li> <li> <p>Boundedness: unbounded (like real numbers); bounded with an origin (UNIX time start); bounded at both (UNIX time start and end 1970-2038 (32 bit))     ends</p> </li> </ul>"},{"location":"data_types_and_operations/#time-density-models","title":"Time Density Models","text":"<p>Time models are distinguished by how many time points exist between two points.</p> <p>Discrete   - The Timeline is isomorphic to the integers. Integers have total order.   - Composed of fixed periods termed chronons.   - Between each pair of chronons is a finite number of chronons.  </p> <p>Dense   - Timeline is isomorphic to rational numbers. Rational numbers have a partial order   - Between each pair of chronons is an infinite number of other chronons.  </p> <p>Continuous   - Timeline is isomorphic to real numbers. Real numbers have a total order   - Between each pair of chronons is an infinite number of other chronons</p> <p>Definition</p> <p>Chronon: the smallest representable time unit (a fixed period) used by a system (e.g.\u00a01 second, 1 minute).</p>"},{"location":"data_types_and_operations/#time-granularity","title":"Time Granularity","text":"<p>Granularity = the resolution used when representing time.</p> <p>Example / Intuition</p> <p>Event A at 11:00 and Event B at 15:00 on the same day:</p> <ul> <li> <p>If granularity = 1 day, A and B occur in the same time unit     \\(\\Rightarrow\\) no precedence is visible.</p> </li> <li> <p>If granularity = 1 minute, A precedes B clearly.</p> </li> </ul> <p>Note</p> <p>Key distinction between:</p> <ul> <li> <p>Sequence: order in which events are recorded/considered</p> </li> <li> <p>Time: actual temporal placement and distance</p> </li> </ul> <p>These can differ (e.g.\u00a0logged later vs happened earlier).</p>"},{"location":"data_types_and_operations/#temporal-data-storage","title":"Temporal Data Storage","text":"<p>A database fact/event can have multiple time notions:</p> <ul> <li> <p>Valid time: when the fact is true in the real world</p> </li> <li> <p>Transaction time: when the fact is current/stored in the DB and     retrievable</p> </li> <li> <p>Bitemporal: storing both valid and transaction time</p> </li> </ul> <p>Example / Intuition</p> <p>A correction scenario (intuition):</p> <ul> <li> <p>A fact could be valid from January, but only inserted into the DB in     March.</p> </li> <li> <p>Valid time captures reality; transaction time captures DB history.</p> </li> </ul> <p>There is no standard extension to SQL for dealing with time related problems. Most vendors have their own ways of handling this.</p>"},{"location":"data_types_and_operations/#temporal-sql-extensions-tsql","title":"Temporal SQL Extensions (TSQL)","text":"<p>Extensions mentioned:</p> <ul> <li> <p>WHEN clause (temporal conditions)</p> </li> <li> <p>Timestamp retrieval</p> </li> <li> <p>Retrieval of temporally ordered information</p> </li> <li> <p><code>TIME-SLICE</code> clause to specify a time domain</p> </li> <li> <p>Modified aggregate functions via <code>GROUP BY</code></p> </li> </ul>"},{"location":"data_types_and_operations/#the-when-clause","title":"The WHEN Clause","text":"<p>Format:</p> <pre><code>SELECT {select-list}\nFROM {relations}\nWHERE {conditions}\nWHEN {temporal clause}\n</code></pre> <p>Temporal comparison operators include:</p> <ul> <li> <p>BEFORE / AFTER</p> </li> <li> <p>PRECEDES / FOLLOWS</p> </li> <li> <p>DURING</p> </li> <li> <p>EQUIVALENT</p> </li> <li> <p>ADJACENT</p> </li> <li> <p>OVERLAPS</p> </li> </ul> <p>Note</p> <p>These operators relate to interval reasoning (as in Allen's Interval Calculus): rather than comparing single timestamps, you compare interval relationships (overlap, adjacency, containment, etc.).</p>"},{"location":"data_types_and_operations/#spatial-data","title":"Spatial Data","text":"<p>Spatial data represents objects in space.</p>"},{"location":"data_types_and_operations/#spatial-data-types","title":"Spatial Data Types","text":"<p>Types include:</p> <ul> <li> <p>Points</p> </li> <li> <p>Regions</p> <ul> <li> <p>Boxes</p> </li> <li> <p>Quadrangles</p> </li> <li> <p>Polynomial surfaces</p> </li> </ul> </li> <li> <p>Vectors</p> </li> </ul>"},{"location":"data_types_and_operations/#spatial-operations","title":"Spatial Operations","text":"<p>Operations Include:</p> <ul> <li> <p>Length</p> </li> <li> <p>Intersection (Do these pair of bounded lines intersect?)</p> </li> <li> <p>Containment (Does this point lie in this region?)</p> </li> <li> <p>Overlap (Do these shapes overlap?)</p> </li> <li> <p>Centre (Geometric centre of a shape)</p> </li> </ul>"},{"location":"data_types_and_operations/#applications-properties","title":"Applications &amp; Properties","text":"<p>Main application areas:</p> <ul> <li> <p>Computer Aided Design (CAD)</p> </li> <li> <p>Computer generated graphics</p> </li> <li> <p>Geographic Information Systems (GIS)</p> </li> </ul> <p>Properties of interest:</p> <ul> <li> <p>Connectivity (what is linked/connected?)</p> </li> <li> <p>Adjacency (what touches what?)</p> </li> <li> <p>Order (arrangement/sequence in space)</p> </li> <li> <p>Metric relations (distances, angles, areas)</p> </li> </ul>"},{"location":"data_types_and_operations/#why-spatial-db-performance-is-hard","title":"Why Spatial DB Performance is Hard","text":"<ul> <li> <p>Objects can be highly complex</p> </li> <li> <p>Data volumes can be very large</p> </li> <li> <p>Real-time constraints may apply</p> </li> <li> <p>Performance is not easy to achieve</p> </li> <li> <p>Often accessed via specialised graphical front-ends (operator skill     matters)</p> </li> <li> <p>Query processing may not use standard SQL</p> </li> </ul>"},{"location":"data_types_and_operations/#multimedia-data","title":"Multimedia Data","text":""},{"location":"data_types_and_operations/#text-data","title":"Text Data","text":"<p>Text may be:</p> <ul> <li> <p>Already machine-readable (word processors, spreadsheets, etc.)</p> </li> <li> <p>Extracted via OCR (For Scanned Text, sometimes image is needed in addition to the text so OCR may not be useful)</p> </li> </ul> <p>Key issue: text is essentially unstructured \\(\\Rightarrow\\) retrieval needs an index:</p> <ul> <li> <p>Human operator index, or</p> </li> <li> <p>Automatically built inverted list (index of significant words     \\(\\rightarrow\\) documents containing them)</p> </li> </ul> <p>Definition</p> <p>Inverted index / inverted list: maps each word (term) to the set of documents that contain it, enabling fast queries like \"find all documents containing word \\(w\\)\".</p> <p>Markup languages add structure:</p> <ul> <li>HTML (web)</li> </ul> <p>XML / SGML (portable documents with structured data; can define new     markup languages)</p> <p>Character Large Objects:</p> <ul> <li>CLOBs (Character Large Objects) for storing text documents</li> <li> <p>Commonly supported by vendors</p> </li> <li> <p>Text search and retrieval facilities</p> </li> </ul>"},{"location":"data_types_and_operations/#document-style-queries-motivation","title":"Document-Style Queries (Motivation)","text":"<p>Typical useful queries:</p> <ul> <li> <p>Legal documents concerning client \"Jones\"</p> </li> <li> <p>Suspects with false teeth who have been interviewed</p> </li> <li> <p>Articles on \"databases\"</p> </li> </ul>"},{"location":"data_types_and_operations/#image-data","title":"Image Data","text":"<p>Examples:</p> <ul> <li>X-rays, maps, photographs</li> </ul> <p>Storage:</p> <ul> <li> <p>Stored as BLOBs (Binary Large Objects)</p> </li> <li> <p>No attached semantics by default (the DB stores bits, not meaning)</p> </li> </ul> <p>Image databases need support for:</p> <ul> <li> <p>Image analysis and pattern recognition</p> </li> <li> <p>Image structuring and understanding</p> </li> <li> <p>Spatial reasoning and image information retrieval</p> </li> </ul> <p>Definition</p> <p>QBIC (Query By Image Content): retrieve images using content features (e.g.\u00a0colour/texture/shape) rather than only filenames/labels.</p>"},{"location":"data_types_and_operations/#audio-data","title":"Audio Data","text":"<p>Digitised audio:</p> <ul> <li> <p>Formats: WAV, MP3</p> </li> <li> <p>Consumes large storage; compression commonly used</p> </li> </ul> <p>MIDI:</p> <ul> <li> <p>More compact than digitised audio</p> </li> <li> <p>Stored as instruction sequences (e.g.\u00a0<code>Note_On</code>, <code>Note_Off</code>,     <code>Increase_Volume</code>)</p> </li> <li> <p>Interpreted by a synthesiser</p> </li> </ul>"},{"location":"data_types_and_operations/#video-data","title":"Video Data","text":"<p>Video characteristics:</p> <ul> <li> <p>Extremely space-hungry</p> </li> <li> <p>Stored as a sequence of frames (each frame can be \\(&gt;\\) 1MB)</p> </li> <li> <p>Playback typically 24--30 fps</p> </li> </ul> <p>Audio-video integration:</p> <ul> <li> <p>Interleaved file structures coordinate time sequencing</p> </li> <li> <p>Examples: Microsoft AVI, Apple QuickTime</p> </li> </ul>"},{"location":"data_types_and_operations/#summary-key-takeaways","title":"Summary - Key Takeaways","text":"<ul> <li> <p>Different data types \\(\\Rightarrow\\) different meaningful operations.</p> </li> <li> <p>Ordering matters: total vs partial order; semantic vs convenience     order.</p> </li> <li> <p>Temporal: structure, boundedness, density     (discrete/dense/continuous), granularity, valid vs transaction time.</p> </li> <li> <p>Spatial: specialised types + geometry operations; large/complex data     makes performance hard.</p> </li> <li> <p>Multimedia:</p> <ul> <li> <p>Text needs indexing (inverted index); markup adds structure     (HTML/XML).</p> </li> <li> <p>Images are BLOBs with no semantics unless analysed; QBIC =     content-based retrieval.</p> </li> <li> <p>Audio/video are storage-heavy; compression and timing/sync are     key.</p> </li> </ul> </li> </ul>"},{"location":"dbms_architecture/","title":"DBMS Architecture","text":"<p>These notes cover the internal architecture of a Database Management System (DBMS), focusing on: - How do we interact with a DBMS, - what components exist inside a DBMS to process queries and manage data.</p>"},{"location":"dbms_architecture/#overview","title":"Overview","text":"<p>Two fundamental questions guide DBMS architecture:</p> <ul> <li>What is the interface to the DBMS?</li> <li>What components exist inside a DBMS?</li> </ul> <p>A DBMS acts as an intermediary between users/applications and stored data, providing abstraction, optimisation, and safe access.</p>"},{"location":"dbms_architecture/#dbms-interfaces","title":"DBMS Interfaces","text":"<p>DBMSs provide different interfaces depending on the task being performed.</p>"},{"location":"dbms_architecture/#ddl-vs-dml","title":"DDL vs DML","text":"<p>Definition \u2014 DDL vs DML</p> <p>DDL (Data Definition Language) Used to define and modify the database schema. - Creating tables - Creating indexes - Altering schemas</p> <p>DML (Data Manipulation Language) Used to query and modify data stored in tables. - Querying data - Inserting, updating, deleting records</p>"},{"location":"dbms_architecture/#high-level-dbms-interfaces","title":"High-Level DBMS Interfaces","text":"<p>A DBMS supports multiple types of users and interaction modes:</p> <ul> <li>Database Administrators     Some DDL statements and potentially some privileged commands.</li> <li>Casual Users     Interactively query using a command line.</li> <li>Application Programmers     People who build database applications, these applications will require an interface for the database as well.</li> </ul>"},{"location":"dbms_architecture/#core-dbms-components","title":"Core DBMS Components","text":"<p>At a high level, a DBMS consists of a frontend and a backend. - The frontend is user facing and is all about executing queries. - The backend is about actually executing the queries and also managing the data that exists behind the scenes.</p> <p></p> <p>The following sections describe each component.</p>"},{"location":"dbms_architecture/#system-catalogue","title":"System Catalogue","text":"<p>Definition \u2014 System Catalogue</p> <p>The system catalogue (also called the data dictionary) stores metadata about the stored data and the database schema</p> <p>It contains information such as:</p> <ul> <li>Names and sizes of files</li> <li>Storage details of files</li> <li>Names and data types of data items</li> <li>Mappings between schemas</li> <li>Constraints (e.g Foreign keys)</li> <li>Statistical information (e.g Number of distinct value on that field)<ul> <li>Used in query optimiser</li> <li>It tells us how expensive certain operations are going to be.</li> </ul> </li> </ul> <p>The system catalogue is consulted heavily during query compilation and optimisation. Any query (DDL or DML) talks to the system catalogue. e.g. if a table exists, update queries will update system catalogue etc.</p>"},{"location":"dbms_architecture/#ddl-compiler","title":"DDL Compiler","text":"<p>Role \u2014 DDL Compiler</p> <p>The DDL compiler processes schema definitions and updates the system catalogue.</p> <p>Responsibilities:</p> <ul> <li>Parses DDL statements</li> <li>Validates schema definitions</li> <li>Stores schema descriptions in the system catalogue</li> </ul>"},{"location":"dbms_architecture/#query-compiler","title":"Query Compiler","text":"<p>Role \u2014 Query Compiler</p> <p>The query compiler parses and validates queries, then converts them into an internal representation (query plans).</p> <p>Responsibilities:</p> <ul> <li>Syntax and semantic checking of queries</li> <li>Compiling queries into an internal form (query plan)</li> <li>Passing compiled queries to the query optimiser (Consults system catalogue, of the possible algorithms, select the best algorithm for this operation)</li> </ul>"},{"location":"dbms_architecture/#query-optimiser","title":"Query Optimiser","text":"<p>Role \u2014 Query Optimiser</p> <p>The query optimiser improves query execution efficiency by transforming the query plan.</p> <p>Key tasks:</p> <ul> <li>Reordering and rearranging operations in the query plan</li> <li>Eliminating redundant operations</li> <li>Selecting appropriate algorithms</li> <li>Choosing suitable indexes</li> <li>Consulting the system catalogue for statistical information</li> <li>Generating executable code for the runtime processor</li> </ul> <p>Note</p> <p>Query optimisation is critical for performance and is one of the most complex components of a DBMS.</p>"},{"location":"dbms_architecture/#precompiler","title":"Precompiler","text":"<p>Role \u2014 Precompiler</p> <p>The precompiler processes application programs that contain embedded DML commands.</p> <p>Responsibilities:</p> <ul> <li>Extracts DML statements from application programs</li> <li>Sends extracted DML to the DML compiler</li> <li>Leaves host-language code unchanged</li> </ul>"},{"location":"dbms_architecture/#dml-compiler","title":"DML Compiler","text":"<p>Role \u2014 DML Compiler</p> <p>The DML compiler compiles data manipulation commands into executable code.</p> <p>Responsibilities:</p> <ul> <li>Compiling DML statements</li> <li>Producing code suitable for execution by the runtime database processor</li> </ul>"},{"location":"dbms_architecture/#runtime-database-processor","title":"Runtime Database Processor","text":"<p>Role \u2014 Runtime Database Processor</p> <p>The runtime database processor executes database operations.</p> <p>Responsibilities:</p> <ul> <li>Executing privileged commands</li> <li>Executing query plans produced by the query optimiser</li> <li>Accessing the database through the stored data manager</li> </ul>"},{"location":"dbms_architecture/#stored-data-manager","title":"Stored Data Manager","text":"<p>Role \u2014 Stored Data Manager</p> <p>The stored data manager controls access to data stored on disk.</p> <p>Responsibilities:</p> <ul> <li>Managing access to disk using operating system services</li> <li>Controlling the shared buffer pool</li> <li>Handling data transfer between disk and main memory</li> </ul> <p>Definition \u2014 Buffer Pool</p> <p>The buffer pool is the portion of main memory used to cache database pages read from disk.</p>"},{"location":"dbms_architecture/#stored-database","title":"Stored Database","text":"<p>The stored database consists of:</p> <ul> <li>Data files on disk</li> <li>Indexes</li> <li>Physical storage structures</li> </ul> <p>All access to the stored database is mediated by the stored data manager.</p>"},{"location":"dbms_architecture/#other-dbms-utilities","title":"Other DBMS Utilities","text":"<p>In addition to core components, DBMSs include utility modules:</p> <ul> <li> <p>Loading utility   Loads files into the database</p> </li> <li> <p>Backup utility   Dumps the database to secondary storage (typically tape)</p> </li> <li> <p>Recovery utility   Handles failures using backup and recovery information</p> </li> <li> <p>File reorganisation utility   Reorganises files to improve performance</p> </li> <li> <p>Performance monitoring   Provides statistics to help the DBA decide when reorganisation is needed</p> </li> </ul>"},{"location":"dbms_architecture/#summary-key-takeaways","title":"Summary \u2014 Key Takeaways","text":"<ul> <li>DBMS architecture separates interfaces, query processing, and data storage</li> <li>DDL defines structure; DML manipulates data</li> <li>The system catalogue stores critical metadata</li> <li>Query compilation and optimisation are distinct phases</li> <li>Runtime execution is separated from storage management</li> <li>Utilities support reliability, performance, and administration</li> </ul>"},{"location":"storage/","title":"Data Storage","text":""},{"location":"storage/#overview","title":"Overview","text":"<p>This lecture covers how databases store and manage data efficiently on secondary storage.</p> <ul> <li>The memory hierarchy and trade-offs between speed, cost, and capacity.</li> <li>Physical organisation of disks and blocks.</li> <li>Buffer management and replacement strategies.</li> <li>The Five-Minute Rule for memory vs disk trade-offs.</li> <li>Representation of data items, records, and blocks.</li> <li>Addressing, pointer swizzling, insertion, and deletion issues.</li> </ul>"},{"location":"storage/#storage-organisation","title":"Storage Organisation","text":""},{"location":"storage/#the-memory-hierarchy","title":"The Memory Hierarchy","text":"<p>Databases rely on multiple levels of storage:</p> <ul> <li>Cache</li> <li>Main Memory</li> <li>Secondary Storage</li> <li>Tertiary Storage</li> </ul> <p>Each level differs in:</p> <ul> <li>Volatility</li> <li>Speed</li> <li>Cost</li> <li>Capacity</li> </ul>"},{"location":"storage/#cache","title":"Cache","text":"<ul> <li>Volatile</li> <li>Very fast</li> <li>Very expensive</li> <li>Limited capacity</li> <li>Hierarchical (Registers \u2192 L1 \u2192 L2)</li> </ul> <p>Typical values: - Registers: ~10\u00b9 bytes, 1 cycle - L1: ~10\u2074 bytes, &lt;5 cycles - L2: ~10\u2075 bytes, 5\u201310 cycles</p>"},{"location":"storage/#main-memory","title":"Main Memory","text":"<ul> <li>Volatile</li> <li>Fast</li> <li>Medium capacity</li> <li>Typical capacity: 10\u2079\u201310\u00b9\u2070 bytes</li> <li>Typical access time: ~10\u207b\u2078 s (20\u201330 cycles)</li> </ul>"},{"location":"storage/#secondary-storage","title":"Secondary Storage","text":"<ul> <li>Non-volatile</li> <li>Slow</li> <li>Cheap</li> <li>Large capacity</li> <li>Typical capacity: 10\u00b9\u00b9\u201310\u00b9\u00b2 bytes</li> <li>Typical access time: ~10\u207b\u00b3 s (~10\u2076 cycles)</li> </ul> <p>Used for: - Persistent database storage - Hard Disk Drives (HDDs)</p>"},{"location":"storage/#tertiary-storage","title":"Tertiary Storage","text":"<ul> <li>Non-volatile</li> <li>Very slow</li> <li>Very cheap</li> <li>Very large capacity</li> <li>Typical capacity: 10\u00b9\u00b3\u201310\u00b9\u2077 bytes</li> <li>Typical access time: 10\u00b9\u201310\u00b2 seconds</li> </ul>"},{"location":"storage/#secondary-storage-hard-disks","title":"Secondary Storage: Hard Disks","text":""},{"location":"storage/#disk-structure","title":"Disk Structure","text":"<p>Disk components:</p> <ul> <li>Track - Concentric tracks</li> <li>Sector - Track sector (a part of the sector which belongs to a single track) and geometrical sector (The whole wedge shaped sector)</li> <li>Cluster</li> <li>Cylinder (same track on all surfaces)</li> </ul> <p></p> <p>Track Sector Size</p> <p>Track sectors at the towards the axis of the disk (inner tracks) are much smaller than tracks closer to the circumference of the disk. Size of the track sectors closer to the axis are the limiting factor, the size of that track sector will determine how much data you can fit in a track sector which will then determine how much data you can fit in a block on disk. </p>"},{"location":"storage/#zone-bit-recording-zbr","title":"Zone Bit Recording (ZBR)","text":"<ul> <li>Outer tracks are longer than inner tracks.</li> <li>Instead of constant bits per track:</li> <li>Number of sectors per track varies.</li> <li>Hybrid of:</li> <li>Constant Linear Velocity (CLV)</li> <li>Constant Angular Velocity (CAV)</li> </ul> <p>Improves storage density.</p> <p></p> <p>Difficulties</p> <p>Zone Bit Recording makes a few things a little more difficult such as addressing.</p>"},{"location":"storage/#disk-sector-format","title":"Disk Sector Format","text":"<p>Each sector contains:</p> <ul> <li>Gap \u2013 separator</li> <li>Sync \u2013 start indicator</li> <li>Address mark \u2013 sector ID</li> <li>Data</li> <li>ECC \u2013 error correcting code</li> </ul> <p>Example (4k Advanced Format):</p> <ul> <li>Gap + sync + mark = 15 bytes</li> <li>Data = 4096 bytes</li> <li>ECC = 100 bytes</li> <li>~2.7% overhead</li> </ul>"},{"location":"storage/#disk-access-time","title":"Disk Access Time","text":""},{"location":"storage/#reading","title":"Reading","text":"<p>Access Time = - Seek Time - + Rotational Delay - + Transfer Time</p>"},{"location":"storage/#seek-time","title":"Seek Time","text":"<p>Time to move head to correct track.</p> <ul> <li>~4 ms (high-end)</li> <li>~15 ms (mobile drives)</li> </ul>"},{"location":"storage/#rotational-delay","title":"Rotational Delay","text":"<p>Average delay = time for 0.5 revolution.</p>"},{"location":"storage/#transfer-time","title":"Transfer Time","text":"<p>Transfer time = block size / transfer rate</p> <p>Transfer rates vary: - Up to 1000 Mbit/s - Blu-Ray ~432 Mbit/s - CD ~1.23 Mbit/s - SSD limited by interface (e.g., SATA 3000 Mbit/s)</p>"},{"location":"storage/#sequential-access","title":"Sequential Access","text":"<p>Sequential I/O avoids repeated seeks and rotational delays.</p> <p>Access time \u2248 - (block size / transfer rate) - + negligible overhead</p> <p>Sequential I/O is much cheaper than random I/O.</p>"},{"location":"storage/#writing","title":"Writing","text":"<p>Similar to reading unless verifying:</p> <p>Access Time = - Seek - + \u00bd rotation - + Write transfer - + Full rotation - + Read transfer (verification)</p>"},{"location":"storage/#modifying-a-block","title":"Modifying a Block","text":"<p>Steps:</p> <ol> <li>Read block</li> <li>Modify in memory</li> <li>Write block</li> <li>Optionally verify</li> </ol> <p>Total includes: - Seek - Rotational delays - Transfer times for read/write - Optional verify costs</p>"},{"location":"storage/#block-addressing","title":"Block Addressing","text":""},{"location":"storage/#physical-addressing","title":"Physical Addressing","text":"<p>Cylinder\u2013Head\u2013Sector</p> <p>Problem: - ZBR makes mapping complex.</p>"},{"location":"storage/#logical-block-addressing-lba","title":"Logical Block Addressing (LBA)","text":"<ul> <li>Blocks identified by integer index.</li> <li>Firmware maps LBA \u2192 physical location.</li> <li>Enables remapping of bad blocks.</li> </ul>"},{"location":"storage/#block-size-selection","title":"Block Size Selection","text":"<p>Trade-offs:</p>"},{"location":"storage/#large-blocks","title":"Large Blocks","text":"<ul> <li>Fewer seeks</li> <li>Lower access overhead</li> <li>Better I/O efficiency</li> </ul> <p>But: - More irrelevant data read if accessing a single record.</p>"},{"location":"storage/#solid-state-drives-ssd","title":"Solid State Drives (SSD)","text":"<p>Characteristics:</p> <ul> <li>NAND flash-based</li> <li>4\u20135\u00d7 more expensive than HDD</li> <li>Smaller maximum capacity (~1\u20132TB typical)</li> <li>Much higher I/O performance</li> <li>Asymmetric read/write (writes slower)</li> <li>Limited program-erase cycles (~100,000)</li> <li>Wear levelling required</li> </ul>"},{"location":"storage/#hdd-vs-ssd-iops","title":"HDD vs SSD: IOPS","text":"<p>IOPS = 1 / (seek + latency + transfer)</p> <p>SSD: - Much higher IOPS - No mechanical seek</p>"},{"location":"storage/#buffer-management","title":"Buffer Management","text":""},{"location":"storage/#buffer-pool","title":"Buffer Pool","text":"<ul> <li>Secondary storage &gt;&gt; main memory</li> <li>Buffer pool organised into frames</li> <li>Each frame = 1 block + metadata</li> </ul>"},{"location":"storage/#buffer-metadata","title":"Buffer Metadata","text":"<p>Each frame has:</p> <ul> <li>Pin count</li> <li>Dirty flag</li> <li>Access time (LRU)</li> <li>Loading time (FIFO)</li> <li>Clock flag (Clock algorithm)</li> </ul>"},{"location":"storage/#requesting-a-block","title":"Requesting a Block","text":"<ol> <li>If block in buffer:</li> <li>Increment pin count.</li> <li>Else if empty frame:</li> <li>Read block.</li> <li>Else:</li> <li>Choose replacement frame.</li> <li>If dirty \u2192 write to disk.</li> <li>Load new block.</li> <li>Set pin count = 1.</li> </ol>"},{"location":"storage/#replacement-strategies","title":"Replacement Strategies","text":"<p>Frame must have pin count = 0.</p>"},{"location":"storage/#lru","title":"LRU","text":"<p>Replace frame with oldest access time.</p>"},{"location":"storage/#fifo","title":"FIFO","text":"<p>Replace frame with oldest loading time.</p>"},{"location":"storage/#clock","title":"Clock","text":"<p>Approximation of LRU.</p> <p>Cycle through frames: - If not accessed in full cycle \u2192 replace.</p>"},{"location":"storage/#single-vs-double-buffering","title":"Single vs Double Buffering","text":""},{"location":"storage/#single-buffering","title":"Single Buffering","text":"<p>Time = n(P + R)</p> <ul> <li>P = process time</li> <li>R = read time</li> <li>n = blocks</li> </ul>"},{"location":"storage/#double-buffering","title":"Double Buffering","text":"<p>Overlap processing and reading.</p> <p>If P &gt; R:</p> <p>Time = R + nP</p> <p>More efficient than single buffering.</p>"},{"location":"storage/#the-five-minute-rule","title":"The Five-Minute Rule","text":"<p>Guideline:</p> <p>Data referenced every five minutes should be memory resident.</p>"},{"location":"storage/#cost-model","title":"Cost Model","text":"<p>If block accessed every X seconds:</p> <p>Cost on disk: CD = $D / (X I)</p> <p>Cost in memory: CM = $M / P</p> <p>Break-even when:</p> <p>X = ($D P) / (I $M)</p>"},{"location":"storage/#historical-examples","title":"Historical Examples","text":""},{"location":"storage/#1997-hdd","title":"1997 (HDD)","text":"<p>X \u2248 266 seconds (~5 minutes)</p>"},{"location":"storage/#2007-hdd","title":"2007 (HDD)","text":"<p>X \u2248 5248 seconds (~1.5 hours)</p>"},{"location":"storage/#2007-ssd","title":"2007 (SSD)","text":"<p>X \u2248 876 seconds (~15 minutes)</p>"},{"location":"storage/#2016-ssd","title":"2016 (SSD)","text":"<p>X \u2248 805 seconds (~13.5 minutes)</p>"},{"location":"storage/#modern-hierarchy-observations","title":"Modern Hierarchy Observations","text":"<ul> <li>SSD viable between DRAM and HDD.</li> <li>DRAM\u2013SSD break-even \u2248 5 minutes.</li> <li>SSD\u2013HDD \u2248 1.5 days.</li> <li>DRAM energy cost &gt; SSD.</li> <li>Likely transition to NVDIMM.</li> </ul>"},{"location":"storage/#disk-organisation","title":"Disk Organisation","text":""},{"location":"storage/#data-items","title":"Data Items","text":"<p>Stored as bytes (8 bits).</p>"},{"location":"storage/#numbers","title":"Numbers","text":"<ul> <li>Integer (2 bytes example)</li> <li>IEEE 754 floating point:</li> <li>1 sign bit</li> <li>Mantissa</li> <li>Exponent</li> </ul>"},{"location":"storage/#characters","title":"Characters","text":"<p>Encodings: - ASCII - UTF-8</p>"},{"location":"storage/#booleans","title":"Booleans","text":"<ul> <li>1 byte per value</li> <li>Can pack bits if necessary.</li> </ul>"},{"location":"storage/#dates","title":"Dates","text":"<ul> <li>Days since origin (e.g., 1 Jan 1900, 1 Jan 1970)</li> <li>ISO8601</li> <li>Calendar: YYYYMMDD</li> <li>Ordinal: YYYYDDD</li> </ul>"},{"location":"storage/#times","title":"Times","text":"<ul> <li>Seconds since midnight</li> <li>ISO8601:</li> <li>HHMMSS</li> <li>HHMMSSFF</li> </ul>"},{"location":"storage/#strings","title":"Strings","text":"<ul> <li>Null-terminated</li> <li>Length-prefixed</li> <li>Fixed length</li> </ul>"},{"location":"storage/#fixed-vs-variable-length","title":"Fixed vs Variable Length","text":"<ul> <li>Fixed: integers, chars</li> <li>Variable: strings, bit arrays</li> <li>May include type info.</li> </ul>"},{"location":"storage/#records","title":"Records","text":""},{"location":"storage/#definition","title":"Definition","text":"<p>Collection of related fields.</p> <p>Example: - Employee:   - Name   - Salary   - Start date</p>"},{"location":"storage/#fixed-format-records","title":"Fixed Format Records","text":"<p>Schema defines: - Fields - Types - Order - Meaning</p> <p>Efficient and compact.</p>"},{"location":"storage/#variable-format-records","title":"Variable Format Records","text":"<p>Self-describing.</p> <p>Useful for: - Sparse records - Repeating fields - Evolving formats</p> <p>More space overhead.</p>"},{"location":"storage/#record-headers","title":"Record Headers","text":"<p>May include:</p> <ul> <li>Record type</li> <li>Length</li> <li>Timestamp</li> </ul>"},{"location":"storage/#blocks","title":"Blocks","text":""},{"location":"storage/#block-header-may-contain","title":"Block Header May Contain","text":"<ul> <li>File ID</li> <li>Block ID</li> <li>Record directory</li> <li>Free space pointer</li> <li>Block type</li> <li>Pointer to similar blocks</li> <li>Timestamp</li> </ul>"},{"location":"storage/#separating-records","title":"Separating Records","text":"<p>Options:</p> <ul> <li>Fixed length</li> <li>Special marker</li> <li>Lengths in header</li> </ul>"},{"location":"storage/#spanned-vs-unspanned","title":"Spanned vs Unspanned","text":"<p>Unspanned: - Record fits in one block.</p> <p>Spanned: - Record split across blocks.</p> <p>Unspanned simpler but may waste space.</p>"},{"location":"storage/#sequencing","title":"Sequencing","text":"<p>Ordering records by key:</p> <ul> <li>Enables efficient sequential access.</li> <li>Useful for merge-join.</li> </ul> <p>Options: - Physically contiguous - Linked records - Overflow area</p>"},{"location":"storage/#indirection","title":"Indirection","text":""},{"location":"storage/#physical-addressing_1","title":"Physical Addressing","text":"<p>Record ID = Device + Cylinder + Head + Sector + Offset</p> <p>Rigid and inflexible.</p>"},{"location":"storage/#indirect-addressing","title":"Indirect Addressing","text":"<p>Record ID = Arbitrary bit string.</p> <p>Mapped to physical address via table.</p> <p>Allows record movement without changing ID.</p>"},{"location":"storage/#address-management","title":"Address Management","text":"<p>Each block/record has:</p> <ul> <li>Database address</li> <li>Memory address (when buffered)</li> </ul> <p>Translation table maps DB \u2192 memory.</p>"},{"location":"storage/#pointer-swizzling","title":"Pointer Swizzling","text":"<p>Convert DB address \u2192 memory pointer.</p> <p>Swizzled pointer contains: - Bit indicating type - Memory or DB address</p> <p>Strategies:</p> <ul> <li>Automatic</li> <li>On-demand</li> <li>No swizzling</li> </ul>"},{"location":"storage/#unswizzling","title":"Unswizzling","text":"<p>Reverse process before unpinning.</p> <p>Necessary because: - Blocks may be pinned by swizzled pointers. - Must restore DB addresses before eviction.</p>"},{"location":"storage/#insertion","title":"Insertion","text":""},{"location":"storage/#easy-case","title":"Easy Case","text":"<ul> <li>Append to end</li> <li>Use deleted slot</li> </ul>"},{"location":"storage/#hard-case-sequenced","title":"Hard Case (Sequenced)","text":"<ul> <li>Insert near correct position</li> <li>Use overflow area</li> </ul> <p>Consider: - How much free space? - When to reorganise?</p>"},{"location":"storage/#deletion","title":"Deletion","text":"<p>Options:</p> <ul> <li>Immediate reclaim</li> <li>Mark as deleted</li> </ul> <p>Issues: - Free space chains - Wasted space - Dangling pointers</p>"},{"location":"storage/#tombstones","title":"Tombstones","text":"<p>Leave marker in:</p> <ul> <li>Map</li> <li>Old location</li> </ul> <p>Logical IDs may: - Never reuse ID - Keep mapping entry</p>"},{"location":"storage/#summary","title":"Summary","text":"<ul> <li>Storage hierarchy defines performance trade-offs.</li> <li>Disk access dominated by seek + latency.</li> <li>Sequential I/O much cheaper than random.</li> <li>Buffer management critical for performance.</li> <li>Five-Minute Rule gives economic guidance.</li> <li>Records, blocks, addressing and swizzling enable flexible storage.</li> <li>Insertion/deletion introduce space and consistency challenges.</li> </ul>"}]}